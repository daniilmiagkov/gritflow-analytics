<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <title>Live Segmentation – отладка графиков</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #container { display: flex; flex-direction: column; align-items: center; }

    #controls { display: flex; gap: 10px; margin-bottom: 10px; }
    input[type="number"] { width: 80px; padding: 5px; font-size: 14px; }

    #status { margin-top: 10px; font-weight: bold; }
    #frameInfo { margin-top: 10px; font-weight: bold; }

    #thresholdContainer { margin-top: 10px; }
    #alertLarge { margin-top: 10px; color: red; font-weight: bold; }

    #overlayContainer {
      margin-top: 20px;
      border: 1px solid #000;
      aspect-ratio: 800/300;
    }
    #segmentedImage {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    #checkboxContainer {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    .checkbox-group {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      border: 1px solid #ccc;
      padding: 8px;
      border-radius: 4px;
      background: #fafafa;
    }
    .checkbox-group h4 {
      margin: 0 0 5px 0;
      font-size: 14px;
    }

    #chartsWrapper {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 40px;
      justify-content: center;
    }
    .chart-box {
      display: none; /* по умолчанию спрятаны */
      flex-direction: column;
      align-items: center;
    }
    .chart-box h4 {
      margin: 0 0 5px 0;
      font-size: 14px;
    }
    .chart-box canvas {
      background: #f4f4f4;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- Управление диапазоном кадров -->
    <div id="controls">
      <label>Стартовый кадр:
        <input type="number" id="startFrame" value="0" min="0" />
      </label>
      <label>Конечный кадр:
        <input type="number" id="endFrame" value="19" min="0" />
      </label>
      <button id="startBtn">Запустить трансляцию</button>
    </div>

    <!-- Статус и номер текущего кадра -->
    <div id="status">Статус: не подключено</div>
    <div id="frameInfo">Кадр: —</div>


    <!-- Блок для оверлея (RGBA image) -->
    <div id="overlayContainer">
      <img id="segmentedImage" src="" alt="Segmentation Overlay" />
    </div>

    <!-- Контейнер для чекбоксов -->
    <div id="checkboxContainer"></div>

    <!-- Контейнер для графиков -->
    <div id="chartsWrapper"></div>

    <!-- Порог для крупных объектов -->
    <div id="thresholdContainer">
      <label for="largeThreshold">Порог крупного объекта (мм): </label>
      <input type="number" id="largeThreshold" value="100" step="1" min="0" />
    </div>

    <div id="alertLarge"></div>
  </div>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    let ws = null;
    const startBtn            = document.getElementById("startBtn");
    const statusDiv           = document.getElementById("status");
    const imgElem             = document.getElementById("segmentedImage");
    const alertLarge          = document.getElementById("alertLarge");
    const largeThresholdInput = document.getElementById("largeThreshold");
    const startInput          = document.getElementById("startFrame");
    const endInput            = document.getElementById("endFrame");
    const frameInfoDiv        = document.getElementById("frameInfo");

    const checkboxContainer   = document.getElementById("checkboxContainer");
    const chartsWrapper       = document.getElementById("chartsWrapper");

    // Объекты Chart.js: { "<suffix>": chartInstance }
    const chartObjects = {};

    let firstMessageHandled = false;

    // Преобразует метку “Depth-Big” → “depth-big”
    function makeSafeKey(label) {
      return label.toLowerCase()
                  .replace(/\s+/g, "_")
                  .replace(/[^a-z0-9_\-]/g, "");
    }

    // Создаёт чекбокс для заданного type ("depth" или "color") и safeLabel
    function createCheckbox(type, safeLabel, displayLabel) {
      const fullSuffix = `${type}_${safeLabel}`;
      const groupId = `checkbox-group-${type}`;

      let groupDiv = document.getElementById(groupId);
      if (!groupDiv) {
        groupDiv = document.createElement("div");
        groupDiv.id = groupId;
        groupDiv.className = "checkbox-group";
        const title = document.createElement("h4");
        title.innerText = (type === "depth" ? "Depth-конфиги" : "Color-конфиги");
        groupDiv.appendChild(title);
        checkboxContainer.appendChild(groupDiv);
      }

      const chk = document.createElement("input");
      chk.type = "checkbox";
      chk.id = `chk-${fullSuffix}`;
      chk.checked = true;

      const lbl = document.createElement("label");
      lbl.htmlFor = chk.id;
      lbl.innerText = displayLabel;

      const wrap = document.createElement("div");
      wrap.appendChild(chk);
      wrap.appendChild(lbl);
      groupDiv.appendChild(wrap);

      // При переключении чекбокса показываем/скрываем график только диагоналей
      chk.addEventListener("change", () => {
        const suffix = `diagonals_${type}_${safeLabel}`;
        const box   = document.getElementById(`chart-${suffix}`);
        if (box) {
          box.style.display = chk.checked ? "flex" : "none";
        }
      });
    }

    // Создаёт контейнер <div> + <canvas> для графика диагоналей
    function createChartBox(titleText, suffix) {
      const box = document.createElement("div");
      box.className = "chart-box";
      box.id = `chart-${suffix}`;
      box.style.display = "flex";
      box.style.flexDirection = "column";
      box.style.alignItems = "center";

      const heading = document.createElement("h4");
      heading.innerText = titleText;
      box.appendChild(heading);

      const canvas = document.createElement("canvas");
      canvas.id = `canvas-${suffix}`;
      canvas.width = 300;
      canvas.height = 200;
      box.appendChild(canvas);

      chartsWrapper.appendChild(box);
      return canvas;
    }

    // При первом сообщении от сервера: создаём чекбоксы и графики под каждый пришедший конфиг (только диагонали)
    function handleFirstMessage(data) {
      console.log("Первое сообщение от сервера; ключи объекта data:", Object.keys(data));

      const depthLabels = new Set();
      const colorLabels = new Set();

      Object.keys(data).forEach(key => {
        // Найдём поля вида "diagonals_depth_<label>_mm"
        if (key.startsWith("diagonals_depth_") && key.endsWith("_mm")) {
          const inside = key.slice("diagonals_depth_".length, -"_mm".length);
          depthLabels.add(inside);
        }
        // Аналогично для color
        if (key.startsWith("diagonals_color_") && key.endsWith("_mm")) {
          const inside = key.slice("diagonals_color_".length, -"_mm".length);
          colorLabels.add(inside);
        }
      });

      // Depth-конфиги
      depthLabels.forEach(safeLabel => {
        const displayLabel = safeLabel
          .split(/[-_]/g)
          .map(w => w.charAt(0).toUpperCase() + w.slice(1))
          .join(" ");
        createCheckbox("depth", safeLabel, displayLabel);

        const suffix = `diagonals_depth_${safeLabel}`;
        createChartBox(`Depth [${displayLabel}] — Распределение диагоналей (мм)`, suffix);
        const canvas = document.getElementById(`canvas-${suffix}`);
        chartObjects[suffix] = new Chart(canvas.getContext("2d"), {
          type: 'bar',
          data: { labels: [], datasets: [{ label: 'Частота', data: [], backgroundColor: 'rgba(54,162,235,0.6)', borderColor: 'rgba(54,162,235,1)', borderWidth: 1 }] },
          options: {
            responsive: false,
            scales: {
              x: { title: { display: true, text: 'Диагональ (мм)' } },
              y: { title: { display: true, text: 'Частота' } }
            }
          }
        });
      });

      // Color-конфиги
      colorLabels.forEach(safeLabel => {
        const displayLabel = safeLabel
          .split(/[-_]/g)
          .map(w => w.charAt(0).toUpperCase() + w.slice(1))
          .join(" ");
        createCheckbox("color", safeLabel, displayLabel);

        const suffix = `diagonals_color_${safeLabel}`;
        createChartBox(`Color [${displayLabel}] — Распределение диагоналей (мм)`, suffix);
        const canvas = document.getElementById(`canvas-${suffix}`);
        chartObjects[suffix] = new Chart(canvas.getContext("2d"), {
          type: 'bar',
          data: { labels: [], datasets: [{ label: 'Частота', data: [], backgroundColor: 'rgba(75,192,192,0.6)', borderColor: 'rgba(75,192,192,1)', borderWidth: 1 }] },
          options: {
            responsive: false,
            scales: {
              x: { title: { display: true, text: 'Диагональ (мм)' } },
              y: { title: { display: true, text: 'Частота' } }
            }
          }
        });
      });

      firstMessageHandled = true;
    }

    // Обновляет переданный график гистограммой по массиву values
    function updateHistogram(chartObj, values, numBins) {
      if (!values || values.length === 0) {
        chartObj.data.labels = [];
        chartObj.data.datasets[0].data = [];
        chartObj.update();
        return;
      }
      if (values.length <= numBins) {
        const m = new Map();
        values.forEach(v => {
          const key = v.toFixed(1);
          m.set(key, (m.get(key) || 0) + 1);
        });
        chartObj.data.labels = Array.from(m.keys());
        chartObj.data.datasets[0].data = Array.from(m.values());
        chartObj.update();
        return;
      }
      const minV = Math.min(...values), maxV = Math.max(...values);
      if (minV === maxV) {
        chartObj.data.labels = [minV.toFixed(1)];
        chartObj.data.datasets[0].data = [values.length];
        chartObj.update();
        return;
      }
      const bins = numBins, range = maxV - minV, binSize = range / bins;
      const labels = [], counts = new Array(bins).fill(0);
      for (let i = 0; i < bins; i++) {
        const left = minV + i * binSize, right = left + binSize;
        labels.push(left.toFixed(1) + "–" + right.toFixed(1));
      }
      values.forEach(v => {
        let idx = Math.floor((v - minV) / binSize);
        if (idx < 0) idx = 0;
        if (idx >= bins) idx = bins - 1;
        counts[idx]++;
      });
      chartObj.data.labels = labels;
      chartObj.data.datasets[0].data = counts;
      chartObj.update();
    }

    function startWebSocket() {
      const startVal = parseInt(startInput.value, 10);
      const endVal   = parseInt(endInput.value, 10);
      if (isNaN(startVal) || isNaN(endVal) || startVal < 0 || endVal < startVal) {
        alert("Введите корректный диапазон: end ≥ start, оба ≥ 0.");
        return;
      }
      if (ws !== null) return;

      const url = `ws://${window.location.host}/ws?start=${startVal}&end=${endVal}`;
      ws = new WebSocket(url);

      ws.onopen = () => {
        statusDiv.innerText = "Статус: подключено";
        startBtn.disabled = true;
      };

      ws.onmessage = event => {
        const data = JSON.parse(event.data);

        // Отладка: выведем в консоль лайв-данные 
        console.log("Получено от сервера:", data);

        // 1) Обновляем оверлей
        imgElem.src = "data:image/png;base64," + data.overlay_b64;

        // 2) Номер кадра
        frameInfoDiv.innerText = `Кадр: ${data.frame}`;

        // 3) Если это первое сообщение — создаём чекбоксы и холсты
        if (!firstMessageHandled) {
          handleFirstMessage(data);
        }

        // 4) Проверяем крупные элементы (диагонали ≥ threshold)
        const thr = parseFloat(largeThresholdInput.value) || 0;
        let foundLarge = false;
        Object.entries(data).forEach(([key, arr]) => {
          if (!Array.isArray(arr)) return;
          if ((key.startsWith("diagonals_depth_") && key.endsWith("_mm")) ||
              (key.startsWith("diagonals_color_") && key.endsWith("_mm"))) {
            for (let v of arr) {
              if (v >= thr) {
                foundLarge = true;
                break;
              }
            }
          }
        });
        alertLarge.innerText = foundLarge ? "Найдены крупные элементы!" : "";

        // 5) Обновляем графики (только диагонали)
        Object.keys(data).forEach(key => {
          const val = data[key];
          if (!Array.isArray(val)) return;  // пропускаем не-массивы

          // Если ключ формата "diagonals_depth_<label>_mm" или "diagonals_color_<label>_mm"
          if ((key.startsWith("diagonals_depth_") || key.startsWith("diagonals_color_")) && key.endsWith("_mm")) {
            // убираем окончание "_mm" → получаем suffix
            const suffix = key.slice(0, -("_mm".length));
            const chartObj = chartObjects[suffix];
            if (!chartObj) {
              console.warn(`Chart-объект не найден для suffix="${suffix}" (key="${key}")`);
              return;
            }
            // Определяем id чекбокса:
            let chkId = null;
            if (suffix.startsWith("diagonals_depth_")) {
              const safeLabel = suffix.replace(/^diagonals_depth_/, "");
              chkId = `chk-depth_${safeLabel}`;
            } else if (suffix.startsWith("diagonals_color_")) {
              const safeLabel = suffix.replace(/^diagonals_color_/, "");
              chkId = `chk-color_${safeLabel}`;
            }
            if (!chkId) return;
            const chk = document.getElementById(chkId);
            if (!chk) {
              console.warn(`Чекбокс не найден для suffix="${suffix}" => chkId="${chkId}"`);
              return;
            }
            // Если чекбокс включён — обновляем диаграмму
            if (chk.checked) {
              updateHistogram(chartObj, val, 20);
            } else {
              // Если отключено, очищаем график
              chartObj.data.labels = [];
              chartObj.data.datasets[0].data = [];
              chartObj.update();
            }
          }
        });
      };

      ws.onclose = () => {
        statusDiv.innerText = "Статус: отключено";
        ws = null;
        startBtn.disabled = false;
      };

      ws.onerror = err => {
        console.error("Ошибка WebSocket:", err);
        statusDiv.innerText = "Статус: ошибка";
      };
    }

    startBtn.addEventListener("click", () => {
      statusDiv.innerText = "Статус: подключение...";
      startWebSocket();
    });
  </script>
</body>
</html>
